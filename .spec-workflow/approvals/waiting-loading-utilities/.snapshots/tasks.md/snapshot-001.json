{
  "id": "snapshot_1761487200000_waiting_loading_tasks",
  "approvalId": "approval_1761487200000_waiting_loading_tasks",
  "approvalTitle": "waiting-loading-utilities tasks approval",
  "version": 1,
  "timestamp": "2025-10-23T00:40:00.000Z",
  "trigger": "approved",
  "status": "approved",
  "content": "# Tasks Document\n\n- [ ] 1. Establish wait configuration contracts\n  - File: packages/core/utils/wait/types.ts (new)\n  - Define `WaitOptions`, `VisibilityOptions`, `IdleWindowOptions`, `WaitResult`, and `WaitError` interfaces with discriminated error codes\n  - Export typed factories through `packages/core/utils/wait/index.ts`\n  - Purpose: Provide strongly typed contracts for waits consumed by workflows, recorder, and HUD telemetry\n  - _Leverage: packages/workflows/src/types.ts, packages/core/resolve.ts_\n  - _Requirements: 1, 4, 5_\n  - _Prompt: Role: TypeScript library engineer specializing in browser automation waits | Task: Create shared wait option/result/error interfaces aligned with requirements 1, 4, and 5, re-exporting through packages/core barrels | Restrictions: Adhere to existing naming conventions, avoid runtime logic, document discriminated union members via JSDoc | Success: Types compile without errors, consumers can import typed options/results, error codes mirror requirements_\n\n- [ ] 2. Implement WaitScheduler with resolver integration\n  - File: packages/core/utils/wait/scheduler.ts (new)\n  - Create scheduler class/functions orchestrating resolver attempts, timeout budgeting, polling loop, and jittered intervals\n  - Inject resolver, clock, telemetry, and logger dependencies via constructor/factory pattern\n  - Purpose: Provide central wait execution engine respecting selector strategy order, retries, and performance caps\n  - _Leverage: packages/core/resolve.ts, packages/core/utils/time.ts_\n  - _Requirements: 1, 4_\n  - _Prompt: Role: Senior TypeScript engineer experienced in async orchestration | Task: Build WaitScheduler coordinating logical key resolution, polling, and timeout caps per requirements 1 and 4 | Restrictions: No setInterval leaks (use clearable handles), respect default ≤150ms polling and ≤8000ms timeouts, attach strategy history to results | Success: Scheduler resolves elements with metadata, obeys caps, emits structured telemetry hooks_\n\n- [ ] 3. Build predicate evaluation modules\n  - File: packages/core/utils/wait/predicates/text.ts & visibility.ts (new)\n  - Implement text, regex, contains, and visibility calculations consuming resolved nodes and producing predicate snapshots\n  - Purpose: Encapsulate predicate logic reused by wait helpers and recorder diagnostics\n  - _Leverage: packages/core/utils/dom.ts, packages/core/utils/sanitize.ts_\n  - _Requirements: 2, 4_\n  - _Prompt: Role: Frontend systems engineer focused on DOM diagnostics | Task: Create predicate evaluators for text and visibility states aligned with requirements 2 and 4 | Restrictions: Mask sensitive text via sanitizer, compute visibility using display/visibility/opacity/bounding box heuristics, return structured snapshots for logging | Success: Predicates report satisfied status accurately, snapshots feed telemetry, stale nodes handled gracefully_\n\n- [ ] 4. Implement mutation idle gate utilities\n  - File: packages/core/utils/wait/idle-gate.ts (new)\n  - Create shared MutationObserver wrapper enforcing idle windows with configurable idle duration and max window cutoffs\n  - Purpose: Provide reusable idle detection for asynchronous rerenders and virtualized content\n  - _Leverage: packages/core/utils/mutation.ts (if exists) or new helper under same directory_\n  - _Requirements: 3, 5_\n  - _Prompt: Role: Browser automation specialist proficient in MutationObserver patterns | Task: Implement idle gate meeting requirements 3 and 5, coordinating idleMs/maxWindowMs and telemetry heartbeat events | Restrictions: Disconnect observers after completion, record last mutation timestamp, respect performance budget | Success: Idle waits resolve when window satisfied, errors contain mutation statistics, integrates with scheduler_\n\n- [ ] 5. Expose wait helper API surface\n  - File: packages/core/utils/wait/index.ts (update)\n  - Export factory `createWaitHelpers(deps)` returning `waitFor`, `waitText`, `waitVisible`, `waitHidden`, `waitForIdle`\n  - Purpose: Provide clear entrypoint for workflows and recorder modules with dependency injection hooks\n  - _Leverage: scheduler.ts, predicates modules, idle gate_\n  - _Requirements: 1, 2, 3_\n  - _Prompt: Role: Library API designer with focus on developer ergonomics | Task: Assemble wait helper exports aligning with requirements 1-3, exposing typed signatures and dependency injection points | Restrictions: Avoid circular imports, surface debug hooks, ensure tree-shakeable structure | Success: Consumers import helpers from core index, helpers call scheduler/predicates correctly, type definitions accessible_\n\n- [ ] 6. Integrate waits into workflow engine executors\n  - File: packages/workflows/src/actions/wait.ts (new or update existing)\n  - Wire `waitFor`, `waitText`, `waitVisible`, `waitHidden`, and idle windows into workflow step executors with telemetry events\n  - Purpose: Ensure workflows leverage new utilities while preserving existing action semantics\n  - _Leverage: packages/workflows/src/engine.ts, packages/workflows/src/telemetry.ts_\n  - _Requirements: 1, 2, 4_\n  - _Prompt: Role: Workflow runtime engineer ensuring action parity | Task: Integrate new wait helpers into workflow executors following requirements 1, 2, and 4 | Restrictions: Maintain backward compatibility for existing steps, propagate structured errors to HUD, support debug logging toggles | Success: Workflow waits use new scheduler, telemetry shows progress, errors include metadata_\n\n- [ ] 7. Coordinate waits with scroll/virtualization utilities\n  - File: packages/core/utils/wait/integration-scroll.ts (new)\n  - Provide helper to sync waits with scroller keys and presence thresholds for virtualized lists\n  - Purpose: Prevent stale element detection and align waits with scrolling utilities when skeleton loaders or virtualization present\n  - _Leverage: packages/core/utils/scroll.ts, scheduler.ts_\n  - _Requirements: 5_\n  - _Prompt: Role: Frontend performance engineer versed in virtualized DOM patterns | Task: Bridge wait helpers with scroll utilities per requirement 5 | Restrictions: Ensure integration optional, avoid redundant scrolling loops, expose configuration via WaitOptions.scrollerKey | Success: Waits coordinate with scroll helper to extend presence thresholds and recover from virtualization delays_\n\n- [ ] 8. Emit `[DGX]` wait telemetry and error narratives\n  - File: packages/core/utils/wait/telemetry.ts (new)\n  - Implement telemetry adapter functions producing heartbeat logs, success/failure entries, and failure messages with guidance\n  - Purpose: Standardize wait logging consumed by HUD, recorder, and console observers\n  - _Leverage: packages/workflows/src/telemetry.ts, existing logging utilities_\n  - _Requirements: 4_\n  - _Prompt: Role: Observability-focused engineer specializing in telemetry schemas | Task: Emit wait lifecycle events and formatted errors per requirement 4 | Restrictions: Mask sensitive data, include strategy histories, align event names with `[DGX] wait:*` convention | Success: Logs appear in HUD timeline with elapsed/poll counts, failure narratives include actionable guidance_\n\n- [ ] 9. Author comprehensive unit and integration tests\n  - File: packages/core/utils/wait/__tests__/scheduler.test.ts (new) + fixtures\n  - Validate resolver fallbacks, text/visibility predicates, idle windows, stale node recovery, and scroller integration scenarios\n  - Purpose: Guarantee reliability across dynamic DOM edge cases before end-to-end coverage\n  - _Leverage: jest/playwright config (existing), fake timers utilities_\n  - _Requirements: 1, 2, 3, 4, 5_\n  - _Prompt: Role: QA automation engineer experienced with DOM testing harnesses | Task: Create unit/integration tests covering requirements 1-5, including dynamic UI and stale node simulations | Restrictions: Use fake timers to control polling, simulate mutation bursts, assert telemetry payloads | Success: Tests assert edge cases, mutation idle windows, timeout enforcement, and logging content_\n\n- [ ] 10. Update recorder export annotations for waits\n  - File: packages/recorder/src/to-workflow.ts (update)\n  - Ensure recorder inserts wait metadata (predicate type, idle window guidance, resolver key hints) and marks dynamic UI edge cases\n  - Purpose: Provide implementers with context when reviewing exported waits and align docs-as-contract principle\n  - _Leverage: packages/recorder/src/to-workflow.ts, wait types_\n  - _Requirements: 2, 4, 5_\n  - _Prompt: Role: Recorder tooling engineer focusing on authoring UX | Task: Enhance recorder exports per requirements 2, 4, and 5 so waits include metadata and guidance | Restrictions: Keep exports deterministic, avoid leaking sensitive text, honor sanitizer rules | Success: Recorder output includes wait annotations and suggestions, workflows compile with new wait types_",
  "fileStats": {
    "size": 8814,
    "lines": 83,
    "lastModified": "2025-10-23T07:11:52.000Z"
  },
  "comments": []
}
