{
  "id": "snapshot_1761486900000_waiting_loading_design",
  "approvalId": "approval_1761486900000_waiting_loading_design",
  "approvalTitle": "waiting-loading-utilities design approval",
  "version": 1,
  "timestamp": "2025-10-23T00:35:00.000Z",
  "trigger": "approved",
  "status": "approved",
  "content": "# Design Document\n\n## Overview\n\nThe waiting and loading utilities provide a shared scheduling layer for DGX workflows that resolves logical selector keys, polls DOM state efficiently, and reports telemetry for HUD and recorder consumers. The design introduces modular helpers for element presence, text predicates, visibility checks, and mutation-idle windows while preserving the TypeScript-first architecture and cross-target compatibility demanded by userscript and MV3 builds.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Implements wait helpers in TypeScript under `packages/core/utils/wait`, reusing existing resolver, logging, and context primitives without introducing new dependencies.\n- Observes steering performance ceilings (≤150ms polling, ≤8000ms default timeout) and `[DGX]` telemetry conventions for debugging.\n- Leverages injected GM-safe timers and avoids `eval`, ensuring parity between userscript and MV3 builds.\n\n### Project Structure (structure.md)\n- Adds focused modules to `packages/core/utils/` and exports typed helpers through `packages/core/index.ts`, maintaining modular boundaries.\n- Exposes orchestration factories for workflows via `packages/workflows`, letting page modules import preconfigured waits without breaking package layering.\n- Stores configuration defaults alongside existing resolver utilities and reuses the centralized selector strategy map to avoid duplication.\n\n## Code Reuse Analysis\n- **Selector Resolver (`@core/resolve`)**: Supplies logical key lookup and fallback ordering. Wait utilities consume resolver responses, including stability metadata, to power diagnostics.\n- **DOM Utilities (`@core/utils/dom`)**: Provides helpers for bounding box, visibility checks, and safe node comparisons.\n- **Telemetry Adapter (`@workflows/telemetry` / HUD timeline)**: Receives structured wait events and renders progress/failure states for operators.\n- **Context Store (`@context/store`)**: Offers optional TTL data for waits dependent on context-driven expectations, enabling dynamic predicate inputs.\n- **Scroll Utilities (`@core/utils/scroll`)**: Integrates with waits that require scroller hydration (e.g., virtualized lists), sharing logic for presence thresholds.\n\n### Existing Components to Leverage\n- **waitUntil helper (if present)**: Either extend or replace prior simple polling utility with the new scheduler to maintain backward compatibility.\n- **Resolver Strategy Map**: Reuse enumerations describing role/name/text/CSS/XPath precedence so that waits and resolver stay aligned.\n- **HUD Event Bus**: Publish wait lifecycle events (`start`, `attempt`, `heartbeat`, `success`, `failure`) for consistent UI updates.\n\n### Integration Points\n- **Workflow Engine**: Accepts wait helpers through dependency injection, letting step executors (`waitFor`, `waitText`, `waitVisible`, `waitIdle`) call into the scheduler.\n- **Recorder Exporter**: Inserts waits into exported workflows and attaches metadata describing predicate type and idle window expectations.\n- **Debug Logger**: Uses shared `[DGX]` logging utilities to emit sanitized diagnostics across both targets.\n\n## Architecture\n\nThe wait system is composed of layered modules that isolate responsibilities and simplify testing.\n\n```mermaid\ngraph TD\n    Resolver[SelectorResolver] --> Scheduler[WaitScheduler]\n    Scheduler --> Poller[Poll Loop]\n    Poller --> Predicates[Predicate Evaluators]\n    Poller --> IdleGate[Mutation Idle Gate]\n    Scheduler --> Telemetry[Telemetry Adapter]\n    Predicates --> DOMUtils[DOM Utilities]\n    IdleGate --> MutationObserver[Shared MutationObserver]\n    Scheduler --> Errors[Error Formatter]\n    ScrollUtils[Scroll Utilities] --> Scheduler\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: `scheduler.ts` coordinates timeouts and polls, `predicates/text.ts` handles text comparisons, `predicates/visibility.ts` computes display state, and `idle/gate.ts` manages mutation observers.\n- **Component Isolation**: Each predicate module receives the resolved node and options, returning discrete status objects consumed by the scheduler.\n- **Service Layer Separation**: Workflows and recorder code depend on exported interfaces (`createWaitHelpers`, `WaitResult`) rather than concrete implementations, enabling mock injection in tests.\n- **Utility Modularity**: Shared constants (`DEFAULT_TIMEOUT_MS`, `DEFAULT_INTERVAL_MS`, `MAX_IDLE_WINDOW_MS`) live in `config.ts`, keeping tuning centralized.\n\n## Components and Interfaces\n\n### `WaitScheduler`\n- **Purpose:** Coordinate polling loops, timeouts, and resolver retries.\n- **Interfaces:** `waitFor(options)`, `waitVisible(options)`, `waitHidden(options)`, `waitText(options)`, `waitForIdle(options)`.\n- **Dependencies:** Selector resolver, clock/timer abstraction, telemetry adapter, jitter generator, error formatter.\n- **Reuses:** Default configuration values and existing resolver strategy metadata.\n\n### `Predicate Evaluators`\n- **Purpose:** Determine whether resolved elements satisfy text, visibility, or custom predicates.\n- **Interfaces:** `evaluateText(node, expectation)`, `evaluateVisibility(node, criteria)`, `evaluateStale(node)`, returning `{ satisfied, snapshot, notes }`.\n- **Dependencies:** DOM utilities for computed styles, bounding boxes, intersection, and sanitized text extraction.\n- **Reuses:** Sanitizer utilities from recorder to mask sensitive captured text.\n\n### `Mutation Idle Gate`\n- **Purpose:** Observe DOM mutations and enforce idle windows before declaring readiness.\n- **Interfaces:** `awaitIdle(targets, { idleMs, maxWindowMs })` returning a promise that resolves when the idle condition passes or rejects on timeout.\n- **Dependencies:** Shared `MutationObserver` wrapper, scheduler timers, telemetry for heartbeat events.\n- **Reuses:** Scroll utilities for virtualized list integration by watching scroller containers.\n\n### `Error Formatter`\n- **Purpose:** Produce structured errors and log payloads containing logical key, strategy attempts, elapsed time, and predicate snapshots.\n- **Interfaces:** `formatTimeoutError(context)`, `formatResolverMiss(context)`, `formatVisibilityError(context)`.\n- **Dependencies:** Selector resolver metadata, predicate snapshots, sanitized text diff utilities.\n- **Reuses:** `[DGX]` logging helpers so HUD displays consistent narratives.\n\n### Configuration Contracts\n- **Purpose:** Encapsulate defaults and override merging for waits.\n- **Interfaces:** `WaitDefaults`, `resolveTimeout(overrides)`, `resolveInterval(overrides)`, `resolveRetryPolicy(context)`.\n- **Dependencies:** Workflow configuration store and environment-level overrides (e.g., debug mode forcing verbose logs).\n- **Reuses:** Existing workflow engine default resolver to keep system-level settings consistent.\n\n## Data Models\n\n### `WaitOptions`\n```\ntype WaitOptions = {\n  key?: string;\n  css?: string;\n  xpath?: string;\n  text?: string;\n  textMode?: \"exact\" | \"contains\" | \"regex\";\n  visibility?: \"visible\" | \"hidden\" | \"any\";\n  timeoutMs?: number;\n  intervalMs?: number;\n  maxRetries?: number;\n  idle?: { idleMs: number; maxWindowMs?: number };\n  scrollerKey?: string;\n  context?: WorkflowContext;\n  debug?: boolean;\n};\n```\n\n### `WaitResult`\n```\ntype WaitResult = {\n  node: Element;\n  strategy: string;\n  attempts: number;\n  elapsedMs: number;\n  predicateSnapshot?: Record<string, unknown>;\n  staleRecoveries: number;\n};\n```\n\n### `WaitError`\n```\ntype WaitError = {\n  code: \"timeout\" | \"resolver_miss\" | \"idle_window_exceeded\" | \"visibility_mismatch\";\n  message: string;\n  key?: string;\n  strategyHistory: string[];\n  elapsedMs: number;\n  pollCount: number;\n  predicateSnapshot?: Record<string, unknown>;\n  lastMutationAt?: number;\n};\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Resolver Exhausted:** All strategies fail before timeout.\n   - **Handling:** Emit `[DGX] wait:resolver_miss` log with strategy history, throw `WaitError` code `resolver_miss`, and suggest registering selector metadata in recorder annotations.\n   - **User Impact:** HUD highlights missing selector information and next steps.\n\n2. **Timeout Without Predicate Satisfaction:** Predicate never resolves before timeout.\n   - **Handling:** Scheduler cancels timers, records final predicate snapshot, and throws `WaitError` code `timeout`.\n   - **User Impact:** HUD displays timeout with elapsed/poll counts; recorder recommends adjusting defaults.\n\n3. **Idle Window Exceeded:** Mutation idle threshold not achieved.\n   - **Handling:** Idle gate terminates observer, logs captured mutation stats, and throws `idle_window_exceeded`.\n   - **User Impact:** Operators see mutation counts to tune `idleMs` or segmentation strategies.\n\n4. **Visibility Mismatch:** Element found but fails visibility predicate.\n   - **Handling:** Retry until timeout with visibility notes; on failure throw `visibility_mismatch` and include computed styles.\n   - **User Impact:** HUD guidance suggests verifying CSS/display toggles or alternative selectors.\n\n5. **Stale Node During Polling:** Node detaches between polls.\n   - **Handling:** Scheduler re-runs resolver within retry limits, increments `staleRecoveries`, and logs recovery events.\n   - **User Impact:** Recorder surfaces dynamic UI note and invites adding idle waits or scroller hints.\n\n## Testing Strategy\n\n### Unit Testing\n- Mock resolver responses to simulate strategy fallbacks, stale nodes, and mismatched visibility states.\n- Validate predicate evaluators against synthetic DOM fixtures (JSDOM) covering exact/contains/regex text matches and opacity/bounding box variations.\n- Test idle gate timing logic with fake timers, ensuring idle windows resolve and max thresholds trigger errors.\n\n### Integration Testing\n- Compose scheduler with real resolver + DOM fixtures to verify telemetry events, heartbeat logging, and structured errors.\n- Simulate virtualized list scenarios to test `presenceThreshold` and `scrollerKey` coordination with scroll utilities.\n- Confirm recorder export + workflow engine integration by executing `waitFor` and `waitText` steps end-to-end with instrumentation.\n\n### End-to-End Testing\n- Run Playwright scenarios on sample pages featuring skeleton loaders, virtualization, and rapid DOM churn to validate wait resilience.\n- Capture HUD telemetry snapshots demonstrating wait progress, heartbeat logs, and error narratives for regression baselines.",
  "fileStats": {
    "size": 10369,
    "lines": 175,
    "lastModified": "2025-10-23T07:10:52.000Z"
  },
  "comments": []
}
