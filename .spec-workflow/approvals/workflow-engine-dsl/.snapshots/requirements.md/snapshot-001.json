{
  "id": "snapshot_1761017913455_gwrh3m9ln",
  "approvalId": "approval_1761017913450_o10uk4niq",
  "approvalTitle": "workflow-engine-dsl requirements approval",
  "version": 1,
  "timestamp": "2025-10-21T03:38:33.455Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nDGX needs a declarative workflow engine and DSL that treats automation as data: every step references logical selector keys, configures safe defaults, and reports state transitions so the HUD, recorder, and runtime stay in sync. This feature defines the workflow schema, execution guarantees, error semantics, and telemetry surface that let authors compose reliable flows without writing imperative code.\n\n## Alignment with Product Vision\n\nThe product charter prioritizes recorder-first authoring, selector stability, and transparent automation. A formal workflow DSL with logical keys, scoped retries, and clear observability gives script authors and AI agents a fast path from recorded steps to dependable automations, reinforcing the Swiss Army Knife scaffold described in product.md and the outcome metrics in project_overview.md.\n\n## Requirements\n\n### Requirement 1\n\n**User Story:** As a script author, I want to describe workflows using a typed DSL so that I can record and maintain automations that only reference logical selector keys and remain resilient across DOM changes.\n\n#### Acceptance Criteria\n\n1. WHEN a workflow step is defined in code or recorder export THEN the schema SHALL require a `kind` discriminant and a `key` or options block that references logical selector keys only (no raw CSS/XPath literals outside explicit `waitFor.css` or `xpath`).\n2. IF a step needs contextual data THEN the DSL SHALL allow `${ctx:path}` and `${env:NAME}` templating or `fromCtx`/`toCtx` fields without leaking masked input values.\n3. WHEN workflows are validated at build time THEN TypeScript types SHALL cover every step kind (click, type, select, waitFor, waitText, delay, hover, focus, blur, setContext, foreach, if, log, assert, scrollUntil, collectList, capture, run, retry policy fields) with optional metadata such as `name`, `timeout`, `retries`, `backoffMs`, `jitterMs`, and `debug`.\n\n### Requirement 2\n\n**User Story:** As a workflow runner, I want the engine to apply consistent defaults for timing and retries so that steps succeed under common latency while failing fast with actionable errors.\n\n#### Acceptance Criteria\n\n1. WHEN executing a step without explicit timing configuration THEN the engine SHALL use default polling intervals ≤ 150ms and default timeouts ≤ 8000ms, overridable per step and per workflow.\n2. IF a step specifies `retries` THEN the engine SHALL perform exponential backoff with optional jitter using defaults defined in configuration (e.g., base 250ms backoff, max 2000ms) while logging each attempt.\n3. WHEN the engine times out or exhausts retries THEN it SHALL emit a structured error containing the logical key, strategies attempted, elapsed time, and next action suggestions, and expose that payload to HUD telemetry and recorder timelines.\n\n### Requirement 3\n\n**User Story:** As a workflow maintainer, I want deterministic control flow constructs so that complex automations remain readable and auditable when using conditionals, loops, and nested workflows.\n\n#### Acceptance Criteria\n\n1. WHEN defining conditional logic THEN the DSL SHALL support `if` steps with `when`, `then`, and optional `else` arrays that execute sequentially using logical key assertions, context checks, or URL predicates.\n2. IF a `foreach` loop is declared THEN it SHALL iterate over context arrays, binding an element alias and executing nested steps with independent retry scopes and timeout overrides.\n3. WHEN invoking reusable workflows via `run` steps THEN the engine SHALL resolve workflow IDs within the current page module registry, propagate context, and surface nested errors with full breadcrumb trails.\n\n### Requirement 4\n\n**User Story:** As a power user or HUD observer, I want clear outcomes and telemetry for every workflow run so that I can diagnose failures quickly and trust success signals.\n\n#### Acceptance Criteria\n\n1. WHEN a workflow starts, completes, or fails THEN the engine SHALL emit `[DGX]`-prefixed events containing workflow ID, step index, logical key (when present), outcome status, and elapsed durations consumable by HUD timeline, recorder replay, and optional analytics sinks.\n2. IF a step logs custom data via `log` or `capture` THEN sensitive values SHALL honor existing sanitize utilities, masking flagged keys or placeholders before display.\n3. WHEN assertions succeed or fail THEN the engine SHALL record the result, including expectation type (exists/notExists/textContains/etc.), evaluated values, and whether retries were used, so acceptance criteria can be audited later.\n\n### Requirement 5\n\n**User Story:** As an AI agent extending DGX, I want scoped workflow configuration so that new page modules inherit consistent defaults while declaring page-specific overrides safely.\n\n#### Acceptance Criteria\n\n1. WHEN defining a page module THEN workflows SHALL declare metadata (id, label, default context seeds, default timeouts) that merges with global workflow engine settings without mutating other modules.\n2. IF a workflow requires page-specific context hydration or cleanup THEN `setContext` and `capture` steps SHALL support TTL and guard rails to prevent stale data across navigation, honoring BroadcastChannel sync policies.\n3. WHEN recorder exports a workflow THEN it SHALL attach recommended defaults and comments for each logical key reference so implementers can map them back to selector metadata during review.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle**: Separate modules SHALL exist for DSL types (`packages/workflows/src/types.ts`), engine execution (`packages/workflows/src/engine.ts`), telemetry/logging adapters, and default configuration, keeping runtime concerns isolated from recorder UI.\n- **Modular Design**: The engine SHALL accept injected resolver, logger, and context store implementations so tests and alternate runtimes reuse the DSL without coupling to browser-only APIs.\n- **Dependency Management**: Prefer existing internal utilities (`@core/utils/wait`, `@core/resolve`, `@context/store`) and avoid introducing new third-party state machines unless approved by steering.\n- **Clear Interfaces**: Provide exported TypeScript interfaces for `Step`, `Workflow`, `WorkflowResult`, `StepError`, and telemetry payloads so HUD, recorder, and scripts share contracts.\n\n### Performance\n- Default polling SHALL stay at or below 150ms and should complete typical waits within 8s; long-running waits must log periodic heartbeats.\n- Engine SHALL batch DOM reads and writes per step to avoid layout thrash, using requestAnimationFrame or microtasks when necessary.\n\n### Security\n- Ensure templated values sanitize or mask secrets before logging; never print raw context paths flagged as sensitive.\n- Forbid executing arbitrary strings as code; all workflow behavior is data-driven through predefined step kinds.\n\n### Reliability\n- Workflows SHALL fail fast with deterministic errors when logical keys are missing, including the selector strategies attempted.\n- Step retries SHALL be bounded to prevent infinite loops and propagate final failure causes to calling workflows.\n\n### Usability\n- Recorder exports SHALL produce human-readable step names and inline comments where ambiguity might slow review.\n- HUD timeline SHALL surface running step names, logical keys, and elapsed times so operators can monitor progress in real time.\n",
  "fileStats": {
    "size": 7426,
    "lines": 86,
    "lastModified": "2025-10-21T03:38:21.785Z"
  },
  "comments": []
}