{
  "id": "snapshot_20251027T084000_dgx_scroll_utilities_design",
  "approvalId": "approval_20251027T084000_dgx_scroll_utilities_design",
  "approvalTitle": "dgx-scroll-utilities-scroll-until design approval",
  "version": 1,
  "timestamp": "2025-10-27T08:40:00.000Z",
  "trigger": "requested",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe DGX scroll utilities expand the core scrolling toolkit with deterministic container detection, safe `scrollIntoView` alignment, and a configurable `scrollUntil` orchestrator. The design introduces modular services under `@core/utils/scroll` that coordinate resolver strategies, scrolling mechanics, telemetry, and recorder integrations while honoring performance budgets and sanitization rules. The resulting APIs enable workflows, recorder replays, and AI agents to automate infinite lists and dynamic feeds with end-to-end observability.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Implemented in strict TypeScript within `packages/core/utils/scroll`, re-exported through barrels while respecting dependency boundaries (core utilities depend on resolver, telemetry, recorder adapters).\n- Enforces steering performance ceilings (\u2264150\u202fms jittered polling, \u22648\u202fs timeout) and `[DGX]` telemetry guidance with sanitized payloads.\n- Uses native DOM APIs (`scrollTo`, `requestAnimationFrame`, `IntersectionObserver`, `MutationObserver`) without introducing new third-party dependencies or unsafe evaluation.\n\n### Project Structure (structure.md)\n- Adds focused modules under `packages/core/utils/scroll` (`container.ts`, `into-view.ts`, `until.ts`, `metrics.ts`, `recording.ts`) with typed exports via `packages/core/index.ts`.\n- Provides integration shims in `packages/recorder` and `packages/workflows` rather than coupling recorder logic into core utilities.\n- Updates workflow engine actions under `packages/workflows/src/actions/scroll.ts` to consume the new helpers, preserving modular boundaries described in structure steering.\n\n## Code Reuse Analysis\n\n- **Selector Resolver (`@core/resolve`)**: Supplies logical selector lookups and strategy history for `mode: \"element\"` and container hints.\n- **Wait Scheduler (`@core/utils/wait`)**: Provides timeout, attempt budgeting, and telemetry adapters reused for `scrollUntil` heartbeat scheduling.\n- **Telemetry Adapter (`@workflows/telemetry`)**: Receives structured `[DGX] scroll:*` events for HUD timelines and recorder playback summaries.\n- **Recorder Serialization (`@recorder/to-workflow`)**: Extends export pipeline to include detected scroll containers, modes, and tuning metadata.\n- **Scroll DOM Helpers (existing)**: Reuse low-level DOM math (clamping, viewport calculations) and extend with new safety inset utilities.\n\n### Existing Components to Leverage\n- **`resolveContainerHint`** (to be extracted from existing scroll helpers): reused and enhanced for heuristic scanning.\n- **`TelemetryEventBus`**: Extended with scroll channels to ensure parity with wait utilities.\n- **`MutationIdleGate`**: Reused to observe list growth and DOM stability when `scrollUntil` monitors `mode: \"list growth\"` or `no_change` states.\n\n### Integration Points\n- **Workflow Engine**: Adds `scrollIntoView` and `scrollUntil` action executors with dependency injection for resolver, telemetry, and timing.\n- **Recorder**: Hooks into capture layer to persist scroll metadata and to supply synthetic predicates during replay.\n- **Selector System**: Provides strategy ordering and stability metadata for element targeting and scroller hints.\n\n## Architecture\n\n```mermaid\ngraph TD\n    Detector[ContainerDetector] --> Runner[ScrollRunner]\n    IntoView[IntoViewController] --> Runner\n    Until[ScrollUntilOrchestrator] --> Runner\n    Runner --> Metrics[TelemetryAdapter]\n    Until --> Predicates[StopPredicateRegistry]\n    Until --> Observer[StabilityObserver]\n    Runner --> RecorderBridge[RecorderBridge]\n    Resolver[SelectorResolver] --> Detector\n    Resolver --> Until\n    WaitScheduler[WaitScheduler] --> Until\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Individual modules handle container detection, into-view alignment, until orchestration, telemetry formatting, and recorder bridging.\n- **Component Isolation**: Orchestrators receive dependencies through factories (`createScrollUtilities(deps)`) to keep resolver, telemetry, and recorder logic swappable for tests.\n- **Service Layer Separation**: Workflow engine interacts only with exported interfaces (`scrollIntoView`, `scrollUntil`) while recorder integrates via bridge hooks.\n- **Utility Modularity**: Shared math helpers (clamping, delta calculation) live in `math.ts`, reused by both `into-view` and `until` modules.\n\n## Components and Interfaces\n\n### `ContainerDetector`\n- **Purpose:** Resolve scroll container using heuristics, hints, and fallbacks, logging decision data.\n- **Interfaces:** `detectContainer(target: Element | null, options: ContainerOptions): ContainerResolution`.\n- **Dependencies:** Selector resolver for hints, DOM utilities for overflow checks, telemetry adapter for diagnostics.\n- **Reuses:** Existing resolver metadata and wait scheduler logging conventions.\n\n### `IntoViewController`\n- **Purpose:** Align elements safely within viewport respecting safety insets and sticky overlays.\n- **Interfaces:** `scrollIntoView(target: Element, opts: IntoViewOptions): Promise<IntoViewResult>`.\n- **Dependencies:** Container detector, DOM math utilities, telemetry adapter, clamp helpers.\n- **Reuses:** Safety inset heuristics from existing HUD overlay adjustments.\n\n### `ScrollUntilOrchestrator`\n- **Purpose:** Coordinate iterative scrolling with multiple stopping modes and tuning controls.\n- **Interfaces:** `scrollUntil(opts: ScrollUntilOptions): Promise<ScrollUntilResult>`; exposes intermediate telemetry through callbacks.\n- **Dependencies:** Container detector, workflow resolver, wait scheduler (for timeout budgeting), predicate registry, stability observer, telemetry adapter.\n- **Reuses:** Wait scheduler\u2019s budget manager to share timing semantics; recorder hooks for metadata capture.\n\n### `StopPredicateRegistry`\n- **Purpose:** Host built-in predicates (`end`, `element`, `list growth`, `predicate`) and allow recorder-supplied functions.\n- **Interfaces:** `evaluate(mode, context): PredicateOutcome` with typed results.\n- **Dependencies:** Selector resolver, DOM query utilities, optional recorder-provided predicate.\n- **Reuses:** Selector history for `element` mode; Mutation idle gate for `list growth`.\n\n### `TelemetryAdapter`\n- **Purpose:** Emit structured `[DGX] scroll:*` events with sanitized payloads.\n- **Interfaces:** `emitStart`, `emitAttempt`, `emitSuccess`, `emitFailure`, `emitNoChange`.\n- **Dependencies:** Workflow telemetry bus, sanitizer utilities, UUID generator for run identifiers.\n- **Reuses:** Logging pipeline used by wait utilities.\n\n### `RecorderBridge`\n- **Purpose:** Exchange metadata between recorder capture/replay and scroll utilities.\n- **Interfaces:** `registerCaptureHooks`, `hydrateReplayContext`, `formatAnnotations`.\n- **Dependencies:** Recorder exporter, telemetry adapter.\n- **Reuses:** Recorder metadata schema for waits and selectors.\n\n## Data Models\n\n### `ScrollUntilOptions`\n```\ntype ScrollUntilMode = \"end\" | \"element\" | \"list_growth\" | \"predicate\";\n\ntype ScrollUntilOptions = {\n  mode: ScrollUntilMode;\n  containerKey?: string;\n  targetSelector?: SelectorKey;\n  listContainerSelector?: SelectorKey;\n  predicate?: (ctx: PredicateContext) => boolean | Promise<boolean>;\n  stepSizePx?: number;\n  maxAttempts?: number;\n  delayMs?: number;\n  timeoutMs?: number;\n  minDeltaPx?: number;\n  listGrowthTarget?: number;\n  recorderContext?: RecorderScrollContext;\n  telemetryRunId?: string;\n};\n```\n\n### `ScrollResult`\n```\ntype ScrollResult = {\n  status: \"success\" | \"timeout\" | \"no_change\" | \"predicate_error\" | \"resolver_miss\" | \"dom_stable_no_match\";\n  attempts: number;\n  elapsedMs: number;\n  lastDelta: { x: number; y: number };\n  containerId: string;\n  targetResolved?: ResolverSummary;\n  listCounts?: { before: number; after: number };\n  predicateSnapshots?: PredicateSnapshot[];\n  domStable?: boolean;\n  telemetryRunId: string;\n};\n```\n\n### `ContainerResolution`\n```\ntype ContainerResolution = {\n  element: Element;\n  strategy: \"hint\" | \"ancestor-overflow\" | \"context\" | \"document\";\n  hintsTried: string[];\n};\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Container Not Found:** Heuristics fail to resolve a scrollable element.\n   - **Handling:** Fallback to `document.scrollingElement`; if null, throw `ScrollError` with code `resolver_miss` and guidance to supply container override.\n   - **User Impact:** HUD displays failure with suggested selector or workflow configuration fix.\n\n2. **Target Resolver Miss (`mode: \"element\"`):** Selector system cannot locate desired element within timeout.\n   - **Handling:** Abort run, emit telemetry with strategy history, and throw structured error referencing selector key.\n   - **User Impact:** Recorder annotation highlights missing selector and suggests re-recording or updating selector map.\n\n3. **Timeout:** Scroll attempts exceed timeout budget without success.\n   - **Handling:** Stop scrolling, emit `scroll:timeout` event with aggregated deltas and attempts, return `status: \"timeout\"`.\n   - **User Impact:** HUD timeline surfaces timeout reason; workflows can branch to recovery or bail.\n\n4. **No Change:** Consecutive deltas under threshold.\n   - **Handling:** Classify as `no_change`, attach DOM stability snapshot, and stop attempts.\n   - **User Impact:** Telemetry and recorder notes explain that additional content was unavailable.\n\n5. **Predicate Error:** Custom predicate throws.\n   - **Handling:** Catch error, sanitize stack trace, log failure, and return `status: \"predicate_error\"`.\n   - **User Impact:** Recorder highlights predicate failure; prompts developer to adjust predicate implementation.\n\n## Testing Strategy\n\n### Unit Testing\n- Validate `ContainerDetector` heuristics with mocked DOM trees (nested overflow, hint attributes, body fallback).\n- Test `IntoViewController` alignment math against sticky header scenarios ensuring safety inset corrections.\n- Ensure predicate registry handles each mode, including error handling and resolver history propagation.\n\n### Integration Testing\n- Compose `scrollUntil` with real resolver mock to simulate infinite list growth, predicate success, and resolver misses.\n- Verify telemetry adapter emits expected events and sanitized payloads in both success and failure flows.\n- Test recorder bridge to confirm captured metadata rehydrates `ScrollUntilOptions` during replay.\n\n### End-to-End Testing\n- Run Playwright scenarios on sample infinite list pages validating each mode plus sticky header alignment.\n- Execute recorder-captured workflows under Tampermonkey and MV3 builds, asserting identical telemetry output and termination codes.\n- Simulate DOM stability/no-change conditions to confirm scroll utilities stop gracefully and surface HUD messaging.\n",
  "fileStats": {
    "size": 10737,
    "lines": 183,
    "lastModified": "2025-10-27T08:12:09.000Z"
  },
  "comments": []
}