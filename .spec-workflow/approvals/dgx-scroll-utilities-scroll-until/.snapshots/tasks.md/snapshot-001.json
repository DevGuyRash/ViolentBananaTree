{
  "id": "snapshot_20251027T084500_dgx_scroll_utilities_tasks",
  "approvalId": "approval_20251027T084500_dgx_scroll_utilities_tasks",
  "approvalTitle": "dgx-scroll-utilities-scroll-until tasks approval",
  "version": 1,
  "timestamp": "2025-10-27T08:45:00.000Z",
  "trigger": "requested",
  "status": "pending",
  "content": "# Tasks Document\n\n- [ ] 1. Implement scroll container detection heuristics\n  - File: packages/core/utils/scroll/container.ts (new)\n  - Build detection helpers that inspect ancestor overflow, DGX hint attributes, and workflow context fallbacks; return strategy metadata for telemetry.\n  - Purpose: Satisfy automatic container detection with clear diagnostics.\n  - _Leverage: packages/core/resolve.ts, packages/core/utils/dom.ts_\n  - _Requirements: 1, 6_\n  - _Prompt: Role: Senior TypeScript engineer specializing in DOM heuristics | Task: Implement container detection honoring DGX hints, ancestor overflow, and document fallbacks with telemetry instrumentation | Restrictions: Avoid direct window globals in tests, expose pure functions for unit coverage | Success: Detector returns container element, strategy history, and logs diagnostics when fallbacks occur_\n\n- [ ] 2. Add safe `scrollIntoView` controller\n  - File: packages/core/utils/scroll/into-view.ts (new)\n  - Calculate alignment offsets, apply safety insets for sticky headers, and verify viewport visibility before resolving.\n  - Purpose: Provide consistent `scrollIntoView` behavior with overscroll protection.\n  - _Leverage: packages/core/utils/scroll/container.ts, packages/core/utils/math.ts_\n  - _Requirements: 2, 5_\n  - _Prompt: Role: Frontend systems engineer focused on scroll ergonomics | Task: Build into-view helper handling alignment options, safety margins, and bounded retries | Restrictions: Use requestAnimationFrame for smoothness, clamp offsets within container ranges | Success: Elements land fully within viewport, retries capped, telemetry logs adjustments_\n\n- [ ] 3. Build `scrollUntil` orchestrator core\n  - File: packages/core/utils/scroll/until.ts (new)\n  - Implement loop managing attempts, timeouts, inter-step delays, and delta tracking across modes.\n  - Purpose: Centralize iterative scroll logic with deterministic termination.\n  - _Leverage: packages/core/utils/scroll/container.ts, packages/core/utils/time.ts, packages/core/utils/wait/budget.ts_\n  - _Requirements: 3, 4, 5_\n  - _Prompt: Role: Async orchestration specialist | Task: Develop scrollUntil engine that merges defaults, enforces budgets, and routes mode-specific predicates | Restrictions: No unbounded loops, respect \u2264500px steps and \u22641000ms delays, expose structured results | Success: Engine handles success, timeout, and no-change status with accurate telemetry_\n\n- [ ] 4. Implement mode predicate registry and list growth observers\n  - File: packages/core/utils/scroll/predicates.ts (new)\n  - Provide predicates for `end`, `element`, `list_growth`, and `predicate`, integrating selector resolver and mutation observers.\n  - Purpose: Modularize stopping logic and support recorder-injected predicates.\n  - _Leverage: packages/core/resolve.ts, packages/core/utils/mutation.ts_\n  - _Requirements: 3, 5_\n  - _Prompt: Role: Browser automation engineer with mutation observer expertise | Task: Create predicate registry covering all modes, including DOM stability measurement | Restrictions: Sanitize predicate errors, reuse mutation idle gate for list growth, expose typed outcomes | Success: Predicates report satisfied states, provide history snapshots, and clean up observers_\n\n- [ ] 5. Emit `[DGX]` scroll telemetry events\n  - File: packages/core/utils/scroll/telemetry.ts (new)\n  - Format lifecycle events (`start`, `attempt`, `success`, `failure`, `no_change`) with sanitized payloads and severity mapping.\n  - Purpose: Deliver observable scroll diagnostics to HUD and recorder timelines.\n  - _Leverage: packages/workflows/src/telemetry.ts, packages/core/utils/sanitize.ts_\n  - _Requirements: 6_\n  - _Prompt: Role: Observability-focused engineer | Task: Implement telemetry adapter aligning with existing wait events and masking sensitive fields | Restrictions: Use consistent event names (`[DGX] scroll:*`), avoid leaking raw selector text | Success: Logs render in HUD timeline with run identifiers and sanitized metadata_\n\n- [ ] 6. Integrate scroll helpers with workflow engine\n  - File: packages/workflows/src/actions/scroll.ts (new) + packages/workflows/src/engine.ts (update)\n  - Wire `scrollIntoView` and `scrollUntil` actions, honoring workflow configuration defaults and propagating structured errors.\n  - Purpose: Expose scroll utilities to declarative workflows.\n  - _Leverage: packages/workflows/src/actions/shared.ts, packages/core/utils/scroll_\n  - _Requirements: 2, 3, 4, 5, 6_\n  - _Prompt: Role: Workflow runtime engineer | Task: Register scroll actions, map DSL options to helper contracts, and forward telemetry to HUD | Restrictions: Maintain backward compatibility for existing scroll steps, ensure errors bubble with reason codes | Success: Workflows execute scroll steps deterministically with telemetry mirrored in HUD_\n\n- [ ] 7. Extend recorder capture and export metadata\n  - File: packages/recorder/src/session.ts (update), packages/recorder/src/to-workflow.ts (update)\n  - Capture heuristic container results, modes, and tuning parameters; emit annotations in exported workflows.\n  - Purpose: Preserve scroll context for playback and AI agents.\n  - _Leverage: packages/recorder/src/annotations.ts, packages/core/utils/scroll/recording.ts_\n  - _Requirements: 6, 7_\n  - _Prompt: Role: Recorder tooling engineer | Task: Inject scroll metadata into capture session and workflow export, providing hooks for predicate replay | Restrictions: Mask sensitive selectors, ensure deterministic serialization, keep bundle size minimal | Success: Recorder exports include scroll annotations and rehydrate options during replay_\n\n- [ ] 8. Create recorder bridge helpers\n  - File: packages/core/utils/scroll/recording.ts (new)\n  - Provide APIs for recorder to register capture hooks, hydrate replay predicates, and format annotations.\n  - Purpose: Decouple recorder integration from core orchestrators.\n  - _Leverage: packages/recorder/src/context.ts, packages/core/utils/scroll/until.ts_\n  - _Requirements: 7_\n  - _Prompt: Role: Integration engineer bridging recorder and core utilities | Task: Build bridge module translating recorder context into scrollUntil options and predicate injections | Restrictions: Avoid circular deps, expose pure helpers for testing | Success: Recorder can inject predicates and container hints without touching orchestrator internals_\n\n- [ ] 9. Author automated acceptance tests across targets\n  - File: packages/tests/scroll/dgx-scroll-until.spec.ts (new) + e2e fixtures\n  - Cover success and failure flows for each mode, sticky header scenarios, and telemetry assertions under Tampermonkey and MV3 builds.\n  - Purpose: Validate end-to-end behavior and parity.\n  - _Leverage: tests/helpers/playwright.ts, apps/userscripts/dev-pages_\n  - _Requirements: 2, 3, 5, 6, 8_\n  - _Prompt: Role: QA automation engineer | Task: Implement cross-target tests verifying scroll heuristics, termination reasons, and telemetry outputs | Restrictions: Use existing fixtures, keep runtime under CI budgets, collect HUD snapshots for documentation | Success: Tests pass on both targets, assert telemetry structure, and capture no-change handling_\n",
  "fileStats": {
    "size": 7137,
    "lines": 73,
    "lastModified": "2025-10-27T08:13:38.000Z"
  },
  "comments": []
}